datasg SEGMENT PARA 'veri'
cr equ 13
lf equ 10
HATA DB CR, LF
n DW ?
dizi DW n DUP(?)
msg1 DB 68,105,122,105,110,105,110,32,101,108,101,109,97,110,32,115,97,121,141,115,141,110,141,32,103,105,114,105,110,58,32,0
msg2 DB 10,101,108,101,109,97,110,108,97,114,141,32,103,105,114,105,110,58,32,0
msg3 DB 10,85,67,71,69,78,32,66,85,76,85,78,65,77,65,68,73,32,0
min DW 0FFFFH
a DW ?
B DW ?
c DW ?
datasg ENDS
stacksg SEGMENT PARA STACK 'yigin'
	Dw 20 DUP(?)
stacksg ENDS
codesg SEGMENT PARA 'kod'
	ASSUME CS:codesg, DS:datasg, SS:stacksg   
	

GETC PROC NEAR
	MOV AH, 1H
	INT 21H
	RET
GETC ENDP

	
GETN PROC NEAR
		PUSH BX
		PUSH CX
		PUSH DX
	GETN_START:
		MOV DX,1
		XOR BX,BX
		XOR CX,CX
	NEW:
		CALL GETC
		CMP AL,CR
		JE FIN_READ
		CMP AL, '-'
		JNE CTRL_NUM
	NEGATÄ°VE:
		MOV DX, -1
		JMP NEW
	CTRL_NUM:
		CMP AL, '0'
		JB ERROR
		CMP AL,'9'
		JA ERROR
		SUB AL, '0'
		MOV BL,AL
		MOV AX, 10
		PUSH DX
		MUL CX
		POP DX
		MOV CX,AX
		ADD CX,BX
		JMP NEW
	ERROR:
		MOV AX,OFFSET HATA
		CALL PUT_STR
		JMP GETN_START
	FIN_READ:
		MOV AX,CX
		CMP DX,1
		JE FIN_GETN
		NEG AX
	FIN_GETN:
		POP DX
		POP CX
		POP DX
		RET
GETN ENDP


PUTN PROC NEAR
		PUSH CX
		PUSH DX
		XOR DX,DX
		PUSH DX
		MOV CX,10
		CMP AX,0
		JGE CALC_DIGITS
		NEG AX
		PUSH AX
		MOV AL, '-'
		CALL PUTC
		POP AX
	CALC_DIGITS:
		DIV CX
		ADD DX,'0'
		PUSH DX
		XOR DX,DX
		CMP AX,0
		JNE CALC_DIGITS
	DISP_LOOP:
		POP AX
		CMP AX,0
		JE END_DISP_LOOP
		CALL PUTC
		JMP DISP_LOOP
	END_DISP_LOOP:
		POP DX
		POP CX
		RET
PUTN ENDP
		
		
PUTC PROC NEAR
	PUSH AX
	PUSH DX
	MOV DL,AL
	MOV AH,2
	INT 21H
	POP DX
	POP AX
	RET
PUTC ENDP

PUT_STR PROC NEAR
		PUSH BX
		MOV BX,AX
		MOV AL,BYTE PTR[BX]
	PUT_LOOP:
		CMP AL,0
		JE PUT_FIN
		CALL PUTC
		INC BX
		MOV AL,BYTE PTR[BX]
		JMP PUT_LOOP
	PUT_FIN:
		POP BX
		RET
PUT_STR ENDP	
	
	
	
	
ANA PROC FAR
	PUSH DS
	XOR AX, AX
	PUSH AX
	MOV AX, datasg
	MOV DS, AX
	
	XOR SI,SI
TEKRAR_GIR:
	XOR AX,AX
	LEA AX,msg1
	CALL PUT_STR	
	XOR AX,AX
	CALL GETN
	PUSH AX
	MOV AX,10
	CALL PUTC
	POP AX
	CMP AX,3
	JL TEKRAR_GIR
	CMP AX,100
	JG TEKRAR_GIR
	MOV n,AX
	XOR CX, CX
	MOV CX,AX
	XOR AX,AX
	LEA AX, msg2
    CALL PUT_STR
    XOR SI,SI
    
dizioku:

	XOR AX,AX
	CALL GETN
	CMP AX,0
	JL dizioku
	CMP AX,1000
	JG dizioku
	MOV dizi[SI],AX
	ADD SI,2
	MOV AL,10
    CALL PUTC
	LOOP dizioku
	
	
	XOR SI,SI
	XOR DI,DI
	XOR BX,BX
	MOV CX,n
	SUB CX,2
		
L1:	
	PUSH CX

	MOV DI,SI
	ADD DI,2
	L2:	
		PUSH CX
	
		MOV BX,DI
		ADD BX,2
		L3:	
			MOV AX, dizi[SI]	;AX = a 
			MOV DX, dizi[DI]
			ADD DX, dizi[BX]	;DX = b+c 
			CMP AX,DX
			JNB DEVAM
			
			SUB DX,dizi[DI]
			ADD DX,dizi[SI]		;DX = a+c
			MOV AX,dizi[DI]		;AX = b
			CMP AX,DX
			JNB DEVAM
			
			SUB DX,dizi[BX]
			ADD DX,dizi[DI] 	;DX = a+b
			MOV AX,dizi[BX]		;AX = c
			CMP AX,DX
			JNB DEVAM
			
			
			ADD AX,DX
			CMP AX,min
			JAE DEVAM
			MOV min,AX
			MOV AX, dizi[SI]
			MOV a, AX
			MOV AX, dizi[DI]
			MOV b, AX
			MOV AX, dizi[BX]
			MOV c, AX
			
			DEVAM: ADD BX,2
		LOOP L3
		
		POP CX
		ADD DI,2
	LOOP L2
	
	POP CX
	ADD SI,2
LOOP	L1      

MOV AX,10
CALL PUTC

MOV AX, 0FFFFH
CMP AX, min
JNE UCGENVAR


XOR AX,AX
LEA AX,msg3
CALL PUT_STR
JMP SON

UCGENVAR:
    MOV AL,40
    CALL PUTC
    MOV AX,a
    CALL PUTN
    MOV AL,44
    CALL PUTC
    MOV AX,b
    CALL PUTN
    MOV AL,44
    CALL PUTC
    MOV AX,c
    CALL PUTN
    MOV AL,41
    CALL PUTC
 
			

SON: RETF
codesg ENDS
	END ANA

